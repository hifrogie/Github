## 1. 중요한 지식들 (코틀린)
### 1. Scope Function
1. 코틀린에서 제공하는 기본 라이브러리 함수로, 객체를 context내에서 코드 단위 블럭으로 실행하는 데 목적을 가진 함수
2. 5개의 스코프 함수가 존재 : let,run,with,apply,also
3. 리시버와 람다 함수
    1. 스코프 함수를 사용할 때 넘겨주는 두 객체
    2. 차이점
        1. 객체를 접근하는 방법 : this, it
            - run,with,apply ->자기 자신 블럭(this)으로 넘기고 this를 사용해 객체에 접근
            - let, also ->자기 자신을 (람다)인자(it)으로 넘기고 it을 사용해 객체에 접근
        2. 리턴 값
            - apply,also ->리시버(context)객체를 마지막에 리턴(자기 자신을 리턴)
            - let,run,with ->람다 함수의 마지막 결과를 리턴(코드 블럭의 결과를 리턴)
4. .let
    1. it으로 리시버에 접근하고 람다 함수의 마지막 결과를 리턴
    2. 리시버에 여러 함수들을 호출할 때 사용
    3. 리시버 객체의 확장 함수로 사용
        - val length = str?.let{it.length}
5. .with
    1. this로 리시버에 접근, 람다함수의 마지막 결과를 리턴
    2. 리턴 값을 사용하지 않는 경우에 쓸 것을 권장
    3. 리시버 객체의 확장 함수로 사용하지 않음 ->with(리시버 객체){람다 함수}
    4. run과 동일한 기능
    5. 인스턴스를 참조연산자 대신 parameter로 받아 사용(run과 차이)
6. .run
    1. this로 리시버에 접근하고, 람다 함수의 마지막 결과를 리턴
    2. 마지막 구문의 결과 값을 반환한다.(apply와 차이)
    3. with와 동일한 기능
    4. 리시버의 확장 함수(extention function)로 사용 ->리시버.run{람다함수}
    5. 람다함수에서 여러 값을 초기화하고 리턴 값을 어떤 객체의 초기값으로 사용할 때 사용
    6. 이미 인스턴스가 만들어진 후에 인스턴스함수나 속성을 scope 내에서 사용해야 할 때 사용한다.
7. .apply
    1. this로 리시버에 접근하고, 리시버 객체를 리턴
    2. 인스턴스를 생성한 후 변수에 담기 전 초기화 과정ㅇ르 수행할 때 많이 사용한다.
    3. main func과 별도의 scope에서 인스턴스의 변수와 함수를 조작한다.
8. .also
    1. it으로 리시버에 접근하고, 리시버 객체를 리턴
    2. 리시버 스스로를 리턴하기 때문에 빌더패턴처럼 연속적으로 함수 호출 가능

9. 특징
    1. 처리가 끝나면 인스턴스를 반환 : apply, also
    2. 처리가 끝나면 최종 값을 반환: run,let,with(?)
    3. 참조 연산자 없이 인스턴스의 변수와 함수 사용: apply,run
    4. 파라미터로 인스턴스를 넘긴 것 처럼 it을 통해 인스턴스를 사용 : also,let