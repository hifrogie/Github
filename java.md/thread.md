## 11. Thread
### 1. Thread
1. java명령어를 사용하여 클래스를 실행시키는 순간 자바 프로세스가 시작되고, main() 메소드가 수행되면서 하나의 쓰레드가 시작되는 것이다.
2. 많은 쓰레드가 필요하다면 main()메소드에서 쓰레드를 생성해주면 된다.
3. 쓰레드를 만든 이유
    - 프로세스를 하나 시작하려면 많은 자원이 필요하다.
    - JVM은 기본적으로 아무런 옵션 없이 실행하면 OS마다 다르지만, 적어도 32MB~64MB의 물리 메모리를 점유한다.
    - 쓰레드는 1MB 이내의 메모리를 점유한다.
    - 쓰레드를 경량 프로세스(light process)라고도 부른다.

### 2. Runnable 인터페이스와 Thread 클래스
1. 쓰레드를 생성하는 방법은 두 가지가 있다. 
2. Runnable 인터페이스를 사용하는 것과 Thread클래스를 사라용하는 방법이 있다.
3. Thread 클래스는 Runnable 인터페이스를 구현한 클래스이다.
4. 모두 java.lang 패키지에 있다. 즉, import할 필요가 없다.
5. 두 가지 방법을 제공하는 이유
    - 어떤 클래스가 어떤 다른 클래스를 extends를 사용해 확장해야 하는 상황인데, 쓰레드로 구현해야할때 인터페이스를 사용한다.

### 3. Runnable 인터페이스

|리턴 타입|메소드 이름 및 매개 변수|설명|
|:-----:|:----------------:|:-:|
|void|run()|쓰레드가 시작되면 수행되는 메소드|

- 쓰레드가 수행되는 우리가 구현하는 메소드는 run()메소드다.
- 쓰레드를 시작하는 메소드는 start()이다.

### 4. Thread 클래스의 생성자

|생성자|설명|
|:--:|:-:|
|Thread()|새로운 쓰레드를 생성한다.|
|Thread(Runnable target)|매개 변수로 받은 target 객체의 run()메소드를 수행하는 쓰레드를 생성한다.|
|Thread(Runnable target,String name)|매개 변수로 받은 target 객체의 run()메소드를 수행하고, name이라는 이름을 갖는 쓰레드를 생성한다.|
|Thread(String name)|name이라는 이름을 갖는 쓰레드를 생성한다.|
|Thread(ThreadGroup group,Runnable target)|매개 변수로 받은 group의 쓰레드 그룹에 속하는 target 객체의 run()메소드를 수행하는 쓰레드를 생성한다.|
|Thread(Group group,Runnable target, String name)|매개 변수로 받은 group의 쓰레드 그룹에 속하는 target 객체의 run()메소드를 수행하고, name이라는 이름을 갖는 쓰레드를 생성한다.|
|Thread(ThreadGroup group,Runnable target,String name,long stackSize)|매개 변수로 받은 group의 쓰레드 그룹에 속하는 target 객체의 run()메소드를 수행하고, name이라는 이름을 갖는 쓰레드를 생성한다. 단 해당 쓰레드의 스택 크기는 stackSize 만큼만 가능하다.|
|Thread(ThreadGroup group,String name)|매개 변수로 받은 group의 쓰레드 그룹에 속하는 name이라는 이름을 갖는 쓰레드를 생성한다.|

### 5. sleep() 메소드

|리턴 타입|메소드 이름 및 매개 변수|설명|
|:-----:|:----------------:|:-:|
|static void|sleep(long millis)|매개 변수로 넘어온 시간(1/1000초)만큼 대기한다.|
|static void|sleep(long millis, int nanos)|첫 번째 매개 변수로 넘어온 시간(1/1000초)+두 번째 매개 변수로 넘어온 시간(1/1000,000,000초) 만큼 대기한다.|

- Thread.sleep() 메소드를 사용할 때에는 항상 try-catch로 묶어 주어야한다.
- 적어도 InterruptedException으로 catch 해주어야한다.

### 6. Thread 클래스의 주요 메소드

|리턴 타입|메소드 이름 및 매개 변수|설명|
|:-----:|:----------------:|:-:|
|void|run()|더 이상 설명이 필요 없는 여러분들이 구현해야 하는 메소드다.|
|long|getId()|쓰레드의 고유 id를 리턴한다. JVM에서 자동으로 생성해준다.|
|String|getName()|쓰레드의 이름을 리턴한다.|
|void|setName(String name)|쓰레드의 이름을 지정한다.|
|int|getPriority()|쓰레드의 우선순위를 확인한다.|
|void|setPriority(int newPriority)|쓰레드의 우선 순위를 지정한다.|
|boolean|isDaemon()|쓰레드가 데몬인지 확인한다.|
|void|setDaemon(boolean on)|쓰레드를 데몬으로 설정할지 아닌지를 설정한다.|
|StackTraceElement[]|getStackTrace()|쓰레드의 스택정보를 확인한다.|
|Thread.State|getState()|쓰레드의 상태를 확인한다.|
|ThreadGroup|getThreadGroup()|쓰레드의 그룹을 확인한다.|

- Priority(우선 순위)는 대기하고 있는 상황에서 더 먼저 수행할 수 있는 순위이다.
- 어떤 쓰레드를 데몬 쓰레드로 지정하면, 그 쓰레드가 수행되고 있든, 아니든 JVM이 끝낼 수 있다. 단, 쓰레드가 시작하기 전에 데몬 쓰레드로 지정되어야한다.

### 7. 프로세서(코어)와 쓰레드의 관계 
1. 프로세서(Processor)
    - 컴퓨터의 운영을 위해 기본적인 명령어에 반응하고 처리하는 논리회로
    - 디바이스가 해야할 일을 총 지휘하는 프로세서를 CPU라고 함(보통 프로세서와 CPU를 같은 의미로 사용)
    - 이외의 프로세스는 제어장치(Control Unit),연산장치(ALU)이 있다.
    - 하나의 CPU내 여러개의 각각의 Core는 OS에게 독립된 Processor로 보인다.
2. 쓰레드
    - 프로세스 내에서 실제로 작업을 수행하는 주체
    - 프로세스 : 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것
3. 관계
    - 하나의 코어가 처리하는 작업을 분할하여 빠르게 처리하고 이 작업하는 단위를 쓰레드라고 합니다.
    - 1코어 1쓰레드일 경우 A를 지시한 뒤 B를 지시하는 개념으로 그 두가지 작업을 따로 처리하지만 만약 1코어 2쓰레드일 경우에는 그 두가지 일을 두 노동자에게 동시에 지시하기 때문에 두가지 작업을 동시에 진행할 수 있습니다.

### 8. 프로세스와 쓰레드의 구조
1. 쓰레드의 구조
    1. 쓰레드는 프로세스가 할당받은 자원을 이용하는 실행 단위다.
    2. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있다.
    3. 쓰레드는 쓰레드 ID,PC,레지스터 집합, 각자의 스택(스택 포인터)으로 구성된다.
        - 쓰레드 ID : 컴퓨트 쉐이더는 자료구조를 입력 받아서 자료구조를 출력하는데, 스레드 ID는 그런 자료구조들을 다양한 방식으로 indexing(색인을 지정해서 특정요소에 접근하는 것)하는데 사용된다.
        - 컴퓨트 쉐이더 : 일반 렌더링 파이프라인과 별도로 그래픽 카드에서 실행되는 프로그램
        - 렌더링 파이프 라인 : GPU를 사용해 리소스를 2D 이미지로 렌더링 하는 과정
        - PC : 실행해야 할 명령어의 위치를 가리키는 레지스터
        - 레지스터 : 프로세스에 위치한 고속 메모리로 극히 소량의 데이터나 처리 중인 중간 결과와도 같은 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역 
        - 스택 포인터 : 주소 레지스터 내의 메모리 단위, 항상 데이터를 삽입해야하는 위치를 의미하는 스택의 최상위 요소
    4. 이를 통해 멀티 쓰레딩을 달성할 수 있는데 멀티쓰레딩은 하나의 프로세스를 여러개의 실행단위(쓰레드)로 나누어서 자원을 공유하며 자원의 생성과 관리의 중복을 줄여 수행능력을 높이는 것이다.
    5. 공유 : 같은 프로세스에 속하는 스레드들은 힙, 데이터, 코드 영역을 공유한다. 추가적으로 open된 파일등도 공유한다.
    6. 공유하지 않는 것 : 각자의 스택과 레지스터(PC 포함)은 공유하지 않는다.
    7. 이렇게 하나의 프로세스 내에서 다수의 실행 단위인 스레드로 구분하여 공유할 자원은 공유하고, 독립적인 것은 따로 두어 수행 능력을 향상시키는 것을 멀티스레딩이라 한다. 

    ![이미지](https://becomeweasel.me/static/d86cddb51ebd04f91e872a4c148a77f9/6af66/thread_memory.png)

    2. 쓰레드에서의 메모리 구조
        1. 프로세스가 할당받은 자원을 이용하는 실행의 단위
        2. 여러개의 스레드는 각자의 레지스터와 스택을 가지지만, 나머지 영역은 가지지 않는다. 대신에 코드, 힙, 데이터 영역을 공유해서 병렬적인 수행이 가능하다.
        3. 쓰레드가 각자의 스택을 가지고 있는 이유?
            - 스레드가 하나의 실행의 context라는 것을 생각하면 자명하다. 그 context 내에서 아주 간단하게 여러개의 지역변수, 파라미터, 반환값, 복귀주소등을 가지는데, 그 스레드들이 만약 서로의 스택을 공유하게 된다면, 그 contaxt가 서로 섞이게 된다.
            - 사실 각자의 스택을 가지기 때문에 스레드가 Lightweight Process라고 불리는 이유다. 
            - 각자의 스택을 가지고 있다고 얘기하지만 사실은 하나의 메모리공간을 stack pointer를 이용해서 분리하는 것이다.
        4. 쓰레드는 왜 각자의 PC와 register도 있을까?
            - PC(Program Counter)나 레지스터의 역할은 현재 명령어가 어디까지 수행되었는지, 수행될때 쓰던 데이터는 무엇이었는지 알려주는 것이다.
            - 스레드는 CPU를 할당받을 때 프로세스 처럼 스케줄러에 의해 결정되는데 그렇기에 명령어가 연속적으로 실행됨을 보장하기 못하기에 어디까지 실행되었는지 기록할 필요가 있는데 그래서 스레드가 각자의 PC를 가지는 것이다.

### 9. 운영체제에서 프로세스와 스레드를 어떻게 다루는가?
1. 프로세스
    1. 운영체제로부터 시스템 자원을 할당 받는 작업의 단위
    2. 프로세스는 운영체제의 스케줄러(scheduler)에 의해 선택되면 실행된다.
        - 한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행할 수 있는 프로세스 중에 하나를 선택하는 역할
    3. 프로세스는 각각 독립된 메모리 영역과 주소 공간을 운영체제로부터 할당 받는다.
    4. 운영체제는 여러 프로세스를 실행 시킬 수 있다.
    5. 운영체제는 프로세스의 실행 사이에 프로세스를 교체하고 재시작할 때 오류가 발생하지 않도록 관리해야하는데 이를 운영체제는 프로세스의 상태를 상태 전이(state transition)를 통해서 체계적으로 관리한다. 
    6. 프로세스 제어 블록(PCB: Process Control Block) 혹은 프로세스 기술자(process descriptor)는 프로세스의 정보를 담고 있는 자료구조다.
    7. 운영체제가 프로세스를 다룰 때 프로세스 제어 블록을 이용해서 다루게 된다.
    8. 아래와 같은 것들이 저장된다.
        - Process State : 프로세스의 상태로 아래에서 살펴본다.
        - Program Counter : 다음 명령어의 주소가 저장된다.
        - CPU Registers : 누산기, 인덱스 레지스터, 스택 포인터, 범용 레지스터 등 컴퓨터 구조에 따라 다르다.
        - CPU-Scheduling Information : 프로세스 우선순위, 스케쥴링 큐의 포인터 등을 일컫는다.
        - Memory-Management Information : 페이지 테이블, 세그먼트 테이블 등 메모리 시스템에 따라 다르다.
        - Accounting Information : CPU 시간의 총량, 실제 사용된 시간, 시간 제한 등에 대한 정보
        - I/O Status Information : 프로세스에 할당된 입출력 기기의 목록
2. 쓰레드
    1. 현대적인 운영체제에서는 하나의 프로세스 내에 여러 스레드가 동시에 존재할 수 있는 (Concurrent) 멀티쓰레딩(Multi-threading)을 지원한다. 실행 중인 프로세스 내에 여러 흐름이 존재할 수 있다는 것
    2. 멀티 쓰레딩
        1. 프로세서가 여러 개인 경우 멀티 스레드를 통해 병렬성(Parallelism)을 높일 수 있다. 즉, 여러 작업이 동시에 수행될 수 있다.
        2. 이는 프로세스의 스레드들이 각각 다른 프로세서에서 병렬적으로 수행될 수 있기 때문이다.
        3. 병렬성은 CPU의 개수에 비례한다.
        4. 만약 프로세서가 하나인 경우에는 멀티 스레드를 통해 동시성(Concurrency)을 높일 수 있다.
        5. 실제로는 각각의 시간에 한 작업만 수행되지만, 병렬적으로 수행되는 것 처럼 보이는 것이다. 

### 10. 코어가 여러개일 때 여러개 쓰레드 사용하는 것
1. 현대의 CPU가 여러개의 코어를 지원함으로써 여러개의 쓰레드를 동시에 실행시킬 수 있다고 하였습니다.
2. 병렬성(Parallelizable)
    1. 어떠한 작업을 여러개의 다른 쓰레드를 이용해서 좀 더 빠르게 수행하는 것을 병렬화(parallelize)라고 합니다.
    2. 프로그램 논리 구조상에서 연산들 간의 의존 관계가 많을 수록 병렬화가 어려워지고, 다른 연산의 결과와 관계없이 독립적으로 수행할 수 있는 구조가 많을수록 병렬화가 쉬워진다.
    3. 실제로 동시에 실행되는 것
    4. 
3. 동시성(concurrency)
    1. 동시에 실행되는 것처럼 보이는 것
    2. 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로, 멀티 태스킹을 위해 여러개의 쓰레드가 번갈아가면서 실행되는 성질
    3. 멀티 스레드로 동시성을 만족시킬 수 있는 것이지 동시성과 멀티스레드는 연관이 없다. 반례로 코틀린은 싱글 스레드에서 코루틴을 이용하여 동시성을 만족할 수 있다.
    4. 코루틴(Coroutine): 싱글 스레드에서도 루틴이라는 단위(맥락상 함수와 동일)로 루틴간 협력이 가능하며, 동시성 프로그래밍을 지원하고 비동기 처리를 쉽게 도와주는 개념을 말한다.
        - 동시성 프로그래밍 : 동시에 실행되는 것처럼 보이는 것
        - 비동기 처리 : 특정 로직의 실행이 끝날 때까지 기다려주지 않고 나머지 코드를 먼저 실행하는 것

### 11. 힙 영역을 공유하면서 발생하는 문제
1. 자바 멀티 스레드 환경에서는 스레드끼리 static 영역과 heap영역을 공유하므로 공유 자원에 대한 동기화 문제를 신경써야한다.
2. synchronized
    1. synchronized 키워드는 스레드 동기화를 할 때 사용하는 대표적인 기법이다.
    2. synchronized를 사용하는 방법으로는 메서드 앞에 키워드 명시, 인스턴스로 사용하기가 있다.
    3. 동기화가 필요한 메서드 앞에 synchronized 키워드만 붙여주면 편리하게 동기화를 적용할 수 있다. 
    4. 인스턴스로 사용하려면 메서드 내부에서 synchronized(메서드){구현}으로 사용할 수 있다.

### 12. Context Switching
1. 여러개의 프로세스가 실행되고 있을 때 기존에 실행되던 프로세스를 중단하고 다른 프로세스를 실행하는 것.
2. 즉, CPU에 실행할 프로세스를 교체하는 기술
3. PCB
    1. context switching은 PCB(Process Context/Control Block)이라고 하는 메모리의 별도 공간에 process 상태 값들을 저장하고, 해당 값들을 찾는 방법으로 구현된다.
    2. PCB는 프로세스가 실행중인 상태를 스냅샷 찍어 저장하는 공간이라고 생각하면 된다.
    3. PCB에 저장되는 내용
        1. Process ID(PID)
        2. 레지스터 값(PC, SP 등)
        3. Scheduling info(프로세스 상태)
        4. Meomory info(메모리 사이즈 linit)-전체 프로세스 사이즈 등
        5. 기타
4. context switching 작동 순서
    1. A라는 프로세스가 running 상태이고 B라는 프로세스가 ready 상태라고 할 때,
    2. 스케줄러가 A 프로세스의 실행을 중단하고 B 프로세스를 실행할 것을 요청함
    3. A 프로세스에서 Stack의 데이터 위치를 가리키고 있는 SP(Stack pointer)의 값과 다음 실행해야하는 코드의 주소 값을 가지고 있는 PC(Program Counter)의 값을 PCB에 저장함(운영체제에서 관리)
    4. SP와 PC는 모두 중앙처리장치 안의 레지스터이다.
        - 중앙처리장치(CPU):컴퓨터 시스템을 통제하고 프로그램의 연산을 실행,처리하는 가장 핵심적인 컴퓨터의 제어장치 혹은 그 기능을 내장한 칩
        - 레지스터 : 프로세서에 위치한 고속 메모리로 극히 소량의 데이터나 처리 중인 중간 결과와도 같은 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역 
    5. A 프로세스는 ready 또는 block 상태로 바뀌고, CPU에서 B 프로세스를 실행함. 이과정을 통해 B프로세스의 상태가 ready에서 running으로 바뀌는데, 이 작업을 dispatch라고 한다.
    6. 반대로 다시 B 프로세스에서 A 프로세스로 컨텍스트 스위칭할 경우 B프로세스의 SP값과 PC값을 PCB에 저장하고(이때 PCB는 A프로세스의 위치 값을 저장하는 PCB와는 별도로 생성되는 메모리 공간임) A프로세스의 PCB에서 SP값과 CP값을 찾아 SP와 PC에 덮어씌움
5. context?
    1. 윈도우나 리눅스 같은 멀티 프로세스 OS에서는 여러개의 프로세스들이 CPU실행시간을 나누는 방식으로 동시에 실행되는 듯한 효과를 얻는다.
    2. 그런데 실행중인 프로세서의 변경은 시스템에 많은 부하를 일으킨다.
    3. CPU 내에 존재하는 레지스터들이 현재 실행 중에 있는 프로세스 관련 데이터로 채워지는데 실행중인 프로세스가 변경되면 CPU 내에 존재하는 레지스터들의 값이 변경되기 때문이다.
    4. 이 경우 다른 프로세스가 실행되고 나서 이전의 프로세스를 재 실행시키기 위하여 레지스터 값들을 어딘가에 저장해야하며, 다른 프로세스의 작업이 완료되면 이전 프로세스의 데이터(레지스터 값)를 복원시켜야한다.
    5. 여기서 프로세스의 데이터(CPU의 레지스터 값)을 context라고 하며, 실행할 프로세스가 바뀔 때마다 레지스터의 값들도 바뀌게 되는데 이를 context switch 라고 한다.