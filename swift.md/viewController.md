## 7. UiViewController
### 1. UiViewController란?
1. UIKit app의 뷰 계층을 관리하는 객체이다.
2. UiViewController는 모든 뷰컨트롤러에 공통된 행동을 정의한다.
3. 뷰컨트롤러의 메인 책임
    1. 일반적으로 기본 데이터 변경에 대한 응답으로 뷰의 콘텐츠를 업데이트
    2. 뷰와의 사용자 상호작용에 응답
    3. 뷰 크기 조정 및 전체 인터페이스 레이아웃 관리
    4. 앱에서 다른 뷰 컨트롤러를 포함한 다른 객체와의 조정
4. 뷰 컨트롤러는 자신이 관리하는 뷰와 긴밀하게 연결되어 있으며 뷰 계층 구조의 이벤트 처리에 참여합니다.
5. 특히, 뷰컨트롤러는 UIResponder객체이며 뷰 컨트롤러의 루트뷰와 해당뷰의 상위 뷰 (일반적으로 다른뷰컨트롤러에 속함)사이에 responder chain에 삽입됩니다.
6. 뷰 컨트롤러의 뷰 중 어느것도 이벤트를 처리하지 않으면 뷰컨트롤러에는 이벤트를 처리하거나 슈퍼뷰에 전달할 수 있는 옵션이 있습니다.
7. 각각의 뷰 컨트롤러는 뷰 계층을 관리한다. 
8. 클래스의 뷰 프로퍼티 안에 저장된 루트뷰는 주로 뷰 계층의 나머지 부분에 대한 컨테이너 역할을 합니다.
9. 루트 뷰의 사이즈와 위치는 부모 뷰컨트롤러나 앱의 윈도우 중 하나가 소유한 객체에 의해 결정된다.
10. 윈도우가 소유한 뷰 컨트롤러는 앱의 루트뷰의 컨트롤러이며 해당 뷰의 크기는 창을 채울수 있도록 조정됩니다.
11. 뷰 컨트롤러는 그들의 뷰를 lazy하게 로딩한다.
12. 처음으로 뷰 프로퍼티에 엑세스하면 뷰 컨트롤러의 뷰가 로드되거나 생성됩니다.
13. 뷰 컨트롤러에서 뷰를 지정하는 방법
    1. storyboard : 뷰 컨트롤러 그리고 뷰컨트롤러의 뷰를 앱의 스토리 보드에 명시한다.스토리보드는 뷰를 지정하는 데 선호되는 방법입니다. 스토리보드에 뷰와 그들의 connection을 뷰 컨트롤러에 명시한다. 또한 관계와 뷰컨트롤러 사이의 segue를 명시할 수 있다.
    2. nib file : nib file을 사용하여 뷰컨트롤러의 뷰를 명시한다. nib file은 싱글 뷰 컨트롤러의 뷰를 명시하도록 시킨다. 하지만 segue와 관계를 정의하도록 하지는 않는다. 또한 nib file은 뷰 컨트롤러 자신의 적은 정보만 저장한다.
    3. loadView() : loadView() 메소드를 사용하여 뷰컨트롤러의 뷰를 명시한다. 뷰 계층을 코드적으로 만들고 해당 계층 구조의 루트뷰를 뷰컨트롤러의 뷰 속성에 할당한다.
14. 뷰 컨트롤러는 뷰컨트롤러의 뷰와 서브뷰들의 유일한 소유주이다. 뷰 컨트롤러는 해당 뷰를 생성하고 뷰 컨트롤러 자체가 해제되는 경우와 같은 적절한 시점에 뷰 소유권을 포기합니다. 스토리보드나 nib file을 사용하여 뷰를 저장하면 뷰 컨트롤러가 뷰 객체를 요청할 때 각 뷰컨트롤러 객체가 해당 뷰의 고유한 복사본을 자동으로 얻습니다. 그러나 수동으로 뷰를 생성하는 경우 각 뷰컨트롤러는 고유한 뷰 집합을 가져야합니다. 뷰컨트롤러 간에 뷰를 공유할 수 없습니다.
15. 뷰컨트롤러의 루트 뷰는 할당된 공간에 맞게 항상 크기가 조정됩니다. 뷰 계층의 다른 뷰에 대해서는 interface builder를 사용하여 뷰의 경계 내에서 각 뷰가 배치되고 크기가 조정되는 방법을 관리하는 자동 레이아웃 constraints를 지정한다. 또한 contraints를 코딩적으로 만들수 있고 적절한 시간에 뷰에 그 constraints를 지정할 수 있다.

### 2.뷰와 관련된 notification을 다룬다.
1. 뷰의 가시성이 변경되면 뷰컨트롤러는 자동적으로 하위클래스가 변화에 응답할수 있도록 메소드를 호출한다.
2. viewIsApprearing(:)과 같은 메소드를 사용하여 뷰가 화면에 표시하도록 준비하고 viewWillDisappear(:)을 사용하여 변경사항이나 다른 상태정보를 저장합니다.다른 방법을 사용하여 적절한 변경을 수행합니다.
3. will callback method는 did callback method와 꼭 쌍을 이루지는 않는다.
4. will callback method를 시작했다면 did와 will callback method 프로세스 둘다 끝내야한다.  

### 3. 뷰의 회전을 다룬다.
1. ios 8
    1. 회전과 관련된 메소드는 deprecated 되었다. 대신 회전은 뷰컨트롤러의 뷰의 사이즈 변화에 의해 다뤄졌다.
    2. 회전은 viewWillTransition(to:with:) 메소드를 사용한 것에 의해 보고 되었다.
    3. 인터페이스 방향이 바뀌었을 때 UIKit는 윈도우의 루트 뷰컨트롤러에서 이 메소드를 호출한다.
    4. 해당 뷰 컨트롤러가 자식 뷰 컨트롤러에 알리며 뷰 컨트롤러 계층에 메세지를 전파한다.
2. ios6, ios7
    1. info.plist file에 정의된 인터페이스 방향을 지원한다.
    2. 뷰컨트롤러는 방향 목록을 제한하기 위해 지원되는 supportedInterfaceOrientations()를 오버라이드 할 수 있다.
    3. 전형적으로 시스템은 이 메소드를 루트뷰컨트롤러의 윈도우나 뷰 컨트롤러가 화면이 전체가 채워진 것이 띄워졌을때 호출 된다.
    4. 자식 뷰 컨트롤러들은 부모 뷰 컨트롤러에 의해 그들에게 제공된 윈도우의 부분을 사용하고 더 이상 지원되는 회전에 대한 결정에 직접 참여하지 않는다.
    5. 앱의 방향 마스크와 뷰 컨트롤러의 방향 마스크의 교차점은 뷰 컨트롤러가 회전할 수 있는 방향을 결정하는 데 사용됩니다.
    6. 특정 방향으로 전체 화면을 표시하려는 뷰 컨트롤러에 대해 preferredInterfaceOrientationForPresentation를 재정의 할 수 있습니다.
    7. 보이는 뷰컨트롤러에 회전이 발생했을때, willRotate(to:duration:), willAnimateRotation(to:duration:), and didRotate(from:) 가 불린다.
    8. viewWillLayoutSubviews()메소드는 뷰가 리사이즈되고 그 부모애 의하여 위치 되었을때 호출된다.
    9. 뷰 컨트롤러가 보이지 않았을 때 화면 전환이 일어나면 화면전환 메소드들은 불리지 않는다. 하지만 viewWillLayoutSubviews()메소드는 호출된다. 뷰가 다시 보일때
    10. 앱이 시작될 때 앱을 항상 인터페이스를 세로방향으로 세팅할 것이다.
    11. application(_:didFinishLaunchingWithOptions:)메소드가 반환 된 후 앱은 팡을 표시하기 전에 위에서 설명한 뷰 컨트롤러 회전 메커니즘을 사용하여 뷰를 적절한 방향으로 회전합니다.

### 4. 뷰 컨트롤러의 콘테이너를 구현한다.
1. 커스텀한 UIViewController 자식 클래스도 또한 컨테이너 뷰컨트롤러로써 행동한다.
2. container viewcontroller는 소유한 다른 뷰 컨트롤러의 콘탠츠 표시를 관리하며 하위 뷰 컨트롤러라고도 합니다. 하위 뷰는 그대로 표시되거나 컨테이너 뷰 컨트롤러가 소유한 뷰와 함께 표시될수 있습니다.
3. 컨테이너 뷰 컨트롤러 하위 클래스는 자식을 연결하기 위해 공용 인터페이스를 선언해야합니다.
4. 이런 메서드의 특성은 사용자에게 달려있으며 생성 중인 컨테이너의 의미에 따라 달라집니다.
5. 뷰컨트롤러의 자식들이 전시될때 그리고 뷰컨트롤러의 계층 중 어디에서 보일지 얼마나 많은 자식들이 뷰컨트롤러에 의해 한번에 보여질 자식수 정해야한다.
6. 뷰 컨트롤러 클래스는 자식이 공유하는 관계(있는경우)를 정의한다.
7. 컨테이너에 대한 public interface를 설정하면 컨테이너가 동작하는 구현 방법에 대한 너무 많은 비공개 세부 정보에 엑세스하지 않고 자녀가 해당기능을 논리적으로 사용하도록 보장합니다.
8. 콘테이너 뷰 컨트롤러는 뷰 계층에 자식의 루트뷰를 추가하기 전에 자신과 컨테이너 뷰 컨트롤러의 자식 뷰컨트롤러와 관련되어 있어야한다.
9. 이것은 iOS가 자식 뷰 컨트롤러들와 해당 컨트롤러가 관리하는 뷰로 이벤트를 적절히 라우트할 수 있게 한다.
10. 마찬가지로 자식 루트 뷰컨트롤러들의 뷰 계층에서 이것을 지운 후에, 이것은 자식 뷰 컨트롤러 의 연결을 자신으로부터 끊길 것이다.
11. 이 연결을 만들 거나 끊을려면 컨테이너는 베이스 클래스에서 정의된 특정한 메소드들을 호출해야한다.
12. 이 메소드들은 컨테이너 클래스의 클라이언드에 의해 호출되는 것이 아니라 컨테이너의 구현에서만 사용하여 예상되는 억제 동작을 제공합니다.
13. 필수적으로 호출해야하는 메소드
    1. addChild(:)
         - 최근 뷰 컨트롤러의 자식으로써 구체적인 뷰컨트롤러를 추가한다.
    2. removeFromParent()
        - 부모로 부터 뷰컨트롤러를 지운다.
    3. willMove(toParent:)
        - 컨테이너 뷰 컨트롤러에서 뷰컨트롤러가 추가되거나 지워지기 전에 호출된다. 
    4. didMove(toParent:)
        - 컨테이너 뷰 컨트롤러에서 뷰 컨트롤러가 추가되거나 지워진 후에 호출된다.