## 1. 함수와 변수
### 1. 함수

```
fun max(a: Int, b:Int):Int{
    return if (a>b) a else b
}
println(max(1,2)) // 2
```
1. 예제
    1. 함수 선언은 fun 키워드로 시작한다.
    2. fun 다음에는 함수 이름이 온다. 예제는 max라는 이름의 함수다.
    3. 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다.
    4. 함수 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론으로 구분해야한다.
    
```
fun max(a: Int, b: Int):Int = if (a>b) a else b
```

2. 식이 본문인 함수
    1. 중괄호를 없애고 return을 제거하면서 등호를 식 앞에 붙이면 더 간결하게 함수를 표현할 수 있다.
    2. 본문이 중괄호로 둘러싸인 함수를 블록이 본문인 함수라 부르고, 등호와 식으로 이뤄진 함수를 식이 본문인 함수라고 부른다.
    3. 식이 본문인 함수의 반환 타입을 생략할 수 있는 이유는 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다. 이런 기능을 타입 추론(type inference)
    4. 식이 본문인 함수의 반환 타입만 생략 가능함 블록이 본문인 함수가 값을 반환 한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다.

### 2. 변수

```
val question = "삶"
val answer = 42
val answer:Int = 42
val frog: String
frog = "green"
```
    
1. 자바에서는 변수를 선언할 때 타입이 맨 앞에 온다. 
2. 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
3. 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수  없다.
4. 그래서 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.
5. 초기과 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없다. 그런 경우 타입을 반드시 지정해야한다.

### 3. 변경 가능한 변수와 변경 불가능한 변수
1. val : 변경 불가능한 참조를 저장하는 변수
2. var : 변경 가능한 참조
3. 기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 필요할 때만 var로 변경하라.
4. 변경 불가능한 참조와 변경 불가능한 객체를 부수효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워짐
    - 부수효과(side effect) : 값을 반환하는 메소드나 함수가 외부상태를 변경하는 경우
    - 함수형 프로그래밍 : 자료처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임
5. val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다.
6. 하지만 어떤 블록이 실행도리 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

```
val messgae: String
if(canPerformOperation()){
    message = "Success"
}
else {
    message = "Failed"
}
```

7. val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수있다.

```
val languages = arrayListOF("Java") //불변 참조를 선언한다.
languages.add("Kotlin")//참조가 가리키는 객체 내부를 변경한다.
```

