## 7. 확장 함수와 확장 프로퍼티
### 1. 확장 함수

```
package strings

fun String.lastChar(): Char = this.get(this.length - 1)
```

1. 정의 : 어떤 클래스의 멤버 메서드인 것 처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다.
2. 확장 함수를 만들려면 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이기만 하면 된다.
3. 클래스의 이름을 수신 객체 타입(receiver type)이라 부른다.
4. 확장함수가 호출되는 대상이 되는 값(객체)을 수신 객체(receiver object)라고 부른다.
5. 이 함수를 호출하는 구문은 다른 일반 클래스 멤버를 호출하는 구문과 똑같다.
6. 어떤 면에서 이는 String 클래스에 새로운 메서드를 추가하는 것과 같다.

### 2. 임포트와 확장 함수

```
import strings.lastChar

val c = "Kotlin".lastChar()
```

```
import strings.lastChar as last
val c = "Kotlin".last()
```


1. 확장 함수를 정의했다고 해도 자동으로 프로젝트 안의 모든 소스코드에서 그 함수를 사용할 수 있지는 않다.
2. 확장함수를 사용하기 위해서는 임포트해야한다.
3. 확장 함수를 정의하자마자 어디서든 그 함수를 쓸 수 있다면 한 클래스에 같은 이름의 확장 함수가 둘 이상 있어서 이름이 충돌하는 경우가 자주 생길 수 있다.
4. 코틀린에서는 클래스를 임포트할 때와 동일한 구문을 사용해 개별 함수를 임포트 할 수 있다.
5. 한 파일 안에서 다른 여러 패키지에 속해있는 이름이 같은 함수를 가져와 사용해야하는 경우 이름을 바꿔서 임포트하면 이름 충돌을 막을 수 있다.

### 3. 확장 프로퍼티

```
val String.lastChar: Char
    get() = get(length - 1)
```

```
var StringBuilder.lastChar: Char
    get() = get(length - 1)
    set(value: Char){
        this.setCharAt(length - 1, value)
    }
```

1. 확장 프로퍼티를 사용하면 기존 클래스 객체에 대한 프로퍼티 형식의 구문으로 사용할 수있는 API를 추가할 수 있다.
2. 프로퍼티라는 이름으로 불리기는 하지만 상태를 저장할 적절한 방법이 없기 때문에 실제로 확장 프로퍼티를 아무 상태도 가질 수 없다.
3. 확장 함수의 경우와 마찬가지로 확장 프로퍼티도 일반적인 프로퍼티와 같은데, 단지 수신 객체 클래스가 추가됐을 뿐이다.
4. 뒷받침하는 필드가 없어서 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의해야한다.
5. 마찬가지로 초기화 코드에서 계산한 값을 담을 장소가 전혀 없으므로 초기화 코드도 쓸 수 없다.
6. StringBuilder에 같은 프로퍼티를 정의한다면 StringBuilder의 맨 마지막 문자는 변경 가능하므로 프로퍼티를 var로 만들 수 있다.