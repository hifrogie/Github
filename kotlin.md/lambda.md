## 14. 람다로 프로그래밍
### 1. 람다 식과 멤버 참조
1. 람다 소개
    1. 람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달할 수 있다.
    2. 람다는 값 처럼 여기저기 전달할 수 있는 동작의 모음이다.
    3. 람다를 따로 선언해서 변수에 저장할 수도 있다.
    4. 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에서 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.
    5. 자바와 다른 점 중 중요한 한가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수있다는 점
    6. 람다 안에서 바깥 변수를 변경해도 된다.
    7. 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다.
2. 멤버 참조
    1. ::를 사용하는 식을 멤버참조(member reference)라고 부른다.
    2. 멤버참조는 프로퍼티나 메서드를 단 하나만 호출하는 함수 값을 만들어준다.
    3. 클래스::멤버
    4. 멤버 참조 뒤에는 괄호를 넣으면 안된다.
    5. 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다.
    6. 최상위에 선언된(그리고 다른 클래스의 멤버가 아닌)함수나 프로퍼티를 참조할 수도 있다.
    7. 생성자 참조(constructor reference)를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다.
    8. :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.

    ```
    data class Person(val name: Stirng, val age: Int)
    val createPerson = ::Person // "Person"의 인스턴스를 만드는 동작을 값으로 저장한다.
    val p = createPerson("Alice",29)
    print(p) //Person(name=Alice ,age=29)
    ```

### 2. 컬렉션 함수형 API
1. 필수적인 함수 : filter와 map
    1. filter와 map은 컬렉션을 활용할 때 기반이 되는 함수다.
    2. filter 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다.

    ```
    val list = listOf(1,2,3,4)
    println(list.filter{ it % 2 == 0 }) //[2,4]
    ```

    3. filter 함수는 컬렉션에서 원치 않는 원소를 제거한다.
    4. 하지만 filter는 원소를 변환할 수는 없다. 원소를 변환하려면 map 함수를 사용해야 한다.
    5. map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.

    ```
    val list = listOf(1,2,3,4)
    println(list.map{it * it}) //[1,4,9,16]
    ```

2. all, any, count, find: 컬렉션에 술어 적용
    1. all, any : 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하는 연산
    2. count : 조건을 만족하는 원소의 개수를 반환
    3. find : 조건을 만족하는 첫 번째 원소를 반환

3. groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경
    1. groupBy : 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해주는 함수

4. flatMap과 flatten : 중첩된 컬렉션 안의 원소 처리
    1. flatMap 함수 : 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(또는 매핑{키 역할을 하는 데이터와 값 역할을 하는 데이터를 짝지어 저장하는 데이터 구조}) 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다.
    2. flatten 함수 : 특별히 변환해야 할 내용이 없다면 리스트의 리스트를 평평하게 펼치기만 하면 된다.

### 3. 지연 계산(lazy) 컬렉션 연산

```
people.asSquence()
    .map(Person::name)
    .filter { it.startsWith("A")}
    .toList()
```

1. 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.
2. sequence를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.
3. 코틀린 지연 계산 시퀸스는 Sequence 인터페이스에서 시작한다.
4. 이 인터페이스는 단지 한 번에 하나씩 열거될 수 있는 원소의 시퀀스를 표현할 뿐이다.
5. Sequence 안에는 iterator라는 단 하나의 메서드가 있다.
6. 그 메서드를 통해 시퀀스로 부터 원소 값을 얻을 수 있다. 

### 4. 자바 함수형 인터페이스 활용

```
button.setOnClickListener {view -> ...}
```

1. 코틀린에서는 무명 클래스 인스턴스 대신 람다를 넘길 수 있다.
2. OnClickListener를 구현하기 위해 사용한 람다에는 view라는 파라미터가 있다. 
3. view의 타입은 View다 . 이는 onclick 메서드의 인자타입과 같다.