## 14. 람다로 프로그래밍
### 1. 람다 식과 멤버 참조
1. 람다 소개
    1. 람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달할 수 있다.
    2. 람다는 값 처럼 여기저기 전달할 수 있는 동작의 모음이다.
    3. 람다를 따로 선언해서 변수에 저장할 수도 있다.
    4. 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에서 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.
    5. 자바와 다른 점 중 중요한 한가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수있다는 점
    6. 람다 안에서 바깥 변수를 변경해도 된다.
    7. 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다.
2. 멤버 참조
    1. ::를 사용하는 식을 멤버참조(member reference)라고 부른다.
    2. 멤버참조는 프로퍼티나 메서드를 단 하나만 호출하는 함수 값을 만들어준다.
    3. 클래스::멤버
    4. 멤버 참조 뒤에는 괄호를 넣으면 안된다.
    5. 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이다.
    6. 최상위에 선언된(그리고 다른 클래스의 멤버가 아닌)함수나 프로퍼티를 참조할 수도 있다.
    7. 생성자 참조(constructor reference)를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있다.
    8. :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다.

    ```
    data class Person(val name: Stirng, val age: Int)
    val createPerson = ::Person // "Person"의 인스턴스를 만드는 동작을 값으로 저장한다.
    val p = createPerson("Alice",29)
    print(p) //Person(name=Alice ,age=29)
    ```

### 2. 컬렉션 함수형 API
1. 필수적인 함수 : filter와 map
    1. filter와 map은 컬렉션을 활용할 때 기반이 되는 함수다.
    2. filter 함수는 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다.

    ```
    val list = listOf(1,2,3,4)
    println(list.filter{ it % 2 == 0 }) //[2,4]
    ```

    3. filter 함수는 컬렉션에서 원치 않는 원소를 제거한다.
    4. 하지만 filter는 원소를 변환할 수는 없다. 원소를 변환하려면 map 함수를 사용해야 한다.
    5. map 함수는 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.

    ```
    val list = listOf(1,2,3,4)
    println(list.map{it * it}) //[1,4,9,16]
    ```

2. all, any, count, find: 컬렉션에 술어 적용
    1. all, any : 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하는 연산
    2. count : 조건을 만족하는 원소의 개수를 반환
    3. find : 조건을 만족하는 첫 번째 원소를 반환

3. groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경
    1. groupBy : 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해주는 함수

4. flatMap과 flatten : 중첩된 컬렉션 안의 원소 처리
    1. flatMap 함수 : 먼저 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(또는 매핑{키 역할을 하는 데이터와 값 역할을 하는 데이터를 짝지어 저장하는 데이터 구조}) 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다.
    2. flatten 함수 : 특별히 변환해야 할 내용이 없다면 리스트의 리스트를 평평하게 펼치기만 하면 된다.

### 3. 지연 계산(lazy) 컬렉션 연산

```
people.asSquence()
    .map(Person::name)
    .filter { it.startsWith("A")}
    .toList()
```

1. 컬렉션 함수를 연쇄하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는다는 말이다.
2. sequence를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄할 수 있다.
3. 코틀린 지연 계산 시퀸스는 Sequence 인터페이스에서 시작한다.
4. 이 인터페이스는 단지 한 번에 하나씩 열거될 수 있는 원소의 시퀀스를 표현할 뿐이다.
5. Sequence 안에는 iterator라는 단 하나의 메서드가 있다.
6. 그 메서드를 통해 시퀀스로 부터 원소 값을 얻을 수 있다. 

### 4. 자바 함수형 인터페이스 활용

```
button.setOnClickListener {view -> ...}
```

1. 코틀린에서는 무명 클래스 인스턴스 대신 람다를 넘길 수 있다.
2. OnClickListener를 구현하기 위해 사용한 람다에는 view라는 파라미터가 있다. 
3. view의 타입은 View다 . 이는 onclick 메서드의 인자타입과 같다.
4. 이런 코드가 작동하는 이유는 OnClickListener에 추상 메서드가 단 하나만 있기 때문이다.
5. 그런 인터페이스를 함수형 인터페이스(functional interface) 또는 SAM 인터페이스라고 한다.
6. SAM은 단일 추상 메서드 single abstract method라는 뜻이다.
7. 코틀린은 함수형 인터페이스를 인자로 취하는 자바 메서드를 호출할 때 람다를 넘길 수 있게 해준다.
8. 자바 메서드에 람다를 인자로 전달
    1. 함수형 인터페이스를 인자로 원하는 자바 메서드에 코틀린 람다를 전달할 수 있다.

    ```java
    void postponeComputation(int delay, Runnable computation);
    ```

    2. 여기서 Runnable 인스턴스라는 말은 실제로는 Runnable을 구현한 무명 클래스의 인스턴스라는 뜻이다.
    3. 컴파일러는 자동으로 그런 무명 클래스와 인스턴스를 만들어준다.
    4. 그 무명 클래스에 있는 유일한 추상 메서드를 구현할 때 람다 본문을 메서드 본문으로 사용한다.
    5. Runnable을 구현하는 무명 객체를 명시적으로 만들어서 사용할 수도 있습니다.
    6. 람다와 무명 객체 사이에는 차이가 있다. 객체를 명시적으로 선언하는 경우 메서드를 호출할 때 마다 새로운 객체가 생성된다.
    7. 람다는 정의가 들어있는 함수의 변수에 접근하지 않는 람다에 대응하는 무명 객체를 메서드를 호출할 때마다 반복 사용한다.
    8. 람다가 주변 영역의 변수를 포획한다면 매 호출마다 같은 인스턴스를 사용할 수 없다. 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다.

9. SAM 생성자
    1. SAM 생성자 : 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다.
    2. 컴파일러가 자동으로 람다를 함수형 인터페이스 무명 클래스로 바꾸지 못하는 경우 SAM 생성자를 사용할 수 있다.
    3. SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다.
    4. SAM 생성자는 그 함수형 인터페이스의 유일한 추상 메서드의 본문에 사용할 람다만을 인자로 받아서 함수형 인터페이스를 구현하는 클래스의 인스턴스를 반환한다.

### 5. 수신 객체 지정 람다: with와 apply
1. 수신 객체 지정 람다(lambda with receiver) : 수신 객체를 명시 하지 않고 람다의 본문 안에서 다른 객체의 메서드를 호출할 수 있게 하는 것
2. with 함수
    1. 언어 구성 요소로 제공하지 않고 with라는 라이브러리 함수를 통해 제공

    ```kotlin
    fun alphabet(): String{
        val result = StringBuilder()
        for(letter in 'A'..'Z'){
            result.append(letter)
        }
        result.append("\nNow I know the alphabet!")
        return result.toString()
    }
    ```

    ```kotlin
    fun alphabet():String {
        val stringBuilder = StringBuilder()
        return with(stringBuilder){ //메서드를 호출하려는 수신 객체를 지정한다.
            for (letter in 'A'..'Z'){
                this.append(letter) //this 를 명시해서 앞에서 지정한 수신 객체의 메서드를 호출한다.
            }
            append("\nNow I know the alphabet!")    //this를 생략하고 메서드를 호출한다.
            this.toString() //람다에서 값을 반환한다.
        }
    }
    ```

    2. with문은 실제로는 파라미터가 2개 있는 함수다. 
    3. 첫 번째 파라미터는 stringBuilder이고, 두 번째 파라미터는 람다다.
    4. with 함수는 첫 번째 인자로 받은 객체를 두 번째 인자로 받은 람다의 수신 객체로 만든다.
    5. 인자로 받은 람다 본문에서는 this를 사용해 그 수신 객체에 접근할 수 있다.
    6. 일반적인 this와 마찬가지로 this와 .을 사용하지 않고 프로퍼티나 메서드 이름만 사용해도 수신 객체의 멤버에 접근할 수 있다.
3. apply 함수
    1. 람다의 결과 대신 수신 객체가 필요한 경우 사용한다.
    2. apply 함수는 거의 with와 같다.
    3. 유일한 차이란 apply는 항상 자신에게 전달된 객체(수신 객체)를 반환한다는 점 뿐이다.
    

