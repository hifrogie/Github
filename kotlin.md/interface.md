## 8. 클래스 계층 정의
### 1. 인터페이스

```
interface Clickable {
    fun click()
}

class Button : Clickable {
    override fun click() = println("I was clicked")
}
fun main(args: Array<String>){
    Button().click() //I was clicked
}
```

1. 코틀린 인터페이스 안에는 추상 메서드 뿐만 아니라 구현이 있는 메서드도 정의할 수 있다.
2. 다만 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.
3. 인터페이스는 interface를 사용한다.
4. 클래스 이름 뒤에 콜론을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.
5. 클래스는 인터페이스를 원하는 만큼 개수 제한 없이 마음대로 구현할 수 있지만, 클래스는 오직 하나만 확장할 수 있다.
6. override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메서드를 오버라이드한다는 표시다.
7. 코틀린에서는 override 변경자를 꼭 사용해야한다. 
8. override 변경자는 실수로 상위 클래스의 메서드를 오버라이드하는 경우를 방지해준다. 
9. 상위클래스에 있는 메서드와 시그니처가 같은 메서드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 안 되기 때문에 override를 붙이거나 메서드 이름을 바꿔야만 한다.
10. 인터페이스 메서드도 디폴트 구현을 제공할 수 있다. 그냥 메서드 본문을 메서드 시그니처 뒤에 추가하면 된다.

### 2. open, final, abstract 변경자

```
open class RichButton : Clickable {
    fun disable(){}
    open fun animate(){}
    override fun click(){}
}
```

1. 취약한 기반 클래스(fragile base class)
    1. 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다.
    2. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메서드를 오버라이드할 위험이 있다.
    3. 모든 하위 클래스를 분석하는 것은 불가능하므로 기반 클래스를 변경하는 경우 하위 클래스의 동작이 예기치않게 바뀔 수도 있다는 면에서 기반 클래스는 취약하다.
2. 취약한 기반 클래스의 해결 방법
    1. 하위 클래스에서 오버라이드하게 의도된 클래스와 메서드가 아니라면 모두 final로 만들라는 뜻
    2. 코틀린의 클래스와 메서드는 기본적으로 final
    3. 어떤 클래스, 메서드, 프로퍼티의 상속을 허용하려면 그 앞에 open 변경자를 붙여야 한다.

|변경자|이 변경자가 붙은 멤버는...|설명|
|:--:|:-------------------:|:-:|
|final|오버라이드할 수 없음|클래스 멤버의 기본 변경자다.|
|open|오버라이드할 수 있음|반드시 open을 명시해야 오버라이드할 수 있다.|
|abstract|반드시 오버라이드 해야함 |추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현이 있으면 안된다.|
|override|상위클래스나 상위 인스턴스의 멤버를 오버라이드하는 중|오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다.|

3. 가시성 변경자

|변경자|클래스 멤버|최상위 선언|
|public|모든 곳에서 볼 수 있다.|모든 곳에서 볼 수 있다.|
|internal|같은 모듈 안에서만 볼 수 있다.|같은 모듈 안에서만 볼 수 있다.|
|protected|하위 클래스 안에서만 볼 수 있다.|(최상위 선언에 적용할 수 없음)|
|private|같은 클래스 안에서만 볼 수 있다.|같은 파일 안에서만 볼 수 있다.|

